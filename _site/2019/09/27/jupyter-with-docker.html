<!doctype html>
<html lang="en">  
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <meta name="theme-color" content="#000000">

        <link href="https://fonts.googleapis.com/css?family=Zilla+Slab:400,500&display=swap" rel="stylesheet">
        <link href="/assets/css/styles.css" rel="stylesheet">
        <link href="/assets/css/prism.css"/ rel="stylesheet">

        <link rel="icon" href="/assets/images/favicon.png" type="image/x-icon">
        <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" />
        
        <title>Jupyter With Docker</title>
        <div class="container nav">
    <h1>I am Leo</h1>
    <div class="nav-buttons">
        <a class="btn" href="/">Home</a>
        <a href="https://github.com/robinovitch61" target="_blank">
            <img id="github" src="/assets/images/github.png" alt="github" title="github">
        </a>
        <a href="https://www.linkedin.com/in/leo-robinovitch-439b98a6/" target="_blank">
            <img id="linkedin" src="/assets/images/linkedin.png" alt="github" title="github">
        </a>
    </div>
</div>
    </head>
    
    <body>
        <div class="container">
    <h2>jupyter with docker</h2>
    I love <a href="https://www.docker.com">docker</a>. It makes environments:
<ul>
    <li>portable across any machine</i></li>
    <li>subject to version control (retraceable history)</li>
    <li>easily deployed and discarded with simple commands</li>
</ul>

Jupyter is a great tool that allows for the creation of nice looking documents consisting of ordered code chunks with inline output. It is a fantastic way to get started with programming, clearly step through your workflow, and/or create stories and presentations out of your work. It runs in the browser after you install it on your machine (i.e. you access it with a URL in your web browser).

<figure class="inline-img">
    <img src="/assets/images/jupyterlab_ex.png" alt="Jupyterlab example.">
    <figcaption class="figcaption-text">From the <a href="https://jupyterlab.readthedocs.io/en/stable/">Jupyterlab Docs</a></figcaption>
</figure>

This walkthrough will get you set up with a jupyter lab (or jupyter notebooks classic) environment that is fully customizable, isolated, version controllable and portable using docker.

<br><br>
If you don't want to use docker, you can always <a href="https://jupyter.org/install">install jupyter the classic way</a>. I like docker for the reasons outlined above (isolation, portability, version controllable, easily deployed/discarded).

<h2 class="h2-text">1: Install Docker</h2>
To install Docker, you'll have to open up a terminal/command prompt and follow the commands below:
<ul>
    <li><a href="https://docs.docker.com/docker-for-mac/install/">Install docker for Mac</a></li>
    <li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/">Install docker for Ubuntu</a></li>
    <li><a href="https://docs.docker.com/docker-for-windows/install/">Install docker for Windows 10</a></li>
</ul>

Once installed, you'll want to open a terminal (or cmd.exe for windows) and enter <code>docker</code>. You should see a long list of options and commands and not something like <code>command 'docker' not found</code>. If you see the long list, you're ready to proceed!

<br><br>
<i>Quick note:</i> docker uses the language of images (<i>recipes for containers</i>) and containers (<i>instances of images</i>). In this specific case, things like <code>jupyter/minimal-notebook</code> and <code>jupyter/pyspark-notebook</code> are <b>images</b> while our <b>container</b> will just be called <code>juptyer</code>.

<h2 class="h2-text">2: Clone the Repo</h2>
You'll need git for this step, which you can <a href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">install here</a> if you don't already have it. You can check by typing <code>git</code> in to the terminal and seeing if the command is found.

<br><br>
What you'll clone is <a href="https://github.com/jupyter/docker-stacks">Project Jupyter's docker-stacks</a>. You can also <a href="https://help.github.com/en/articles/fork-a-repo">fork</a> this repo and clone your fork. We'll go through adding a couple files to this repo that will make deployment and customizing things easy. You can use <a href="https://github.com/robinovitch61/docker-stacks">my fork</a> or this tutorial as a reference. To clone the <code>docker-stacks</code> repo, run the following command in terminal/command prompt:

<pre><code class="language-bash"># run in the desired directory, e.g. ~/projects 
git clone https://github.com/jupyter/docker-stacks.git
</code></pre>

<br>
The <code>docker-stacks</code> directory we just cloned contains a lot of stuff. We're going to look at just a few bits of a few important files. First, the <code>Dockerfile</code> in the "base-notebook" directory:

<pre><code class="language-bash">############################################
## docker-stacks/base-notebook/Dockerfile ##
############################################

# Copyright (c) Jupyter Development Team.
# Distributed under the terms of the Modified BSD License.

# Ubuntu 18.04 (bionic) from 2019-06-12
# https://github.com/tianon/docker-brew-ubuntu-core/commit/3c462555392cb188830b7c91e29311b5fad90cfe
ARG BASE_CONTAINER=ubuntu:bionic-20190612@sha256:9b1702dcfe32c873a770a32cfd306dd7fc1c4fd134adfb783db68defc8894b3c
FROM $BASE_CONTAINER

LABEL maintainer="Jupyter Project"
ARG NB_USER="jovyan"
ARG NB_UID="1000"
ARG NB_GID="100"
# ...
</code></pre>

I like to think of a container as an isolated environment that my app/service (in this case, jupyter) will run in, almost entirely isolated from the rest of my host machine. This <code>Dockerfile</code> specifies that all jupyter containers will derive from a Linux Ubuntu "bionic" OS (<code>BASE_CONTAINER=ubuntu...</code>).

<br><br>
If you examine the <code>Dockerfile</code>s for other directories, you'll see there's a chain of derivations that end in the base-notebook:

<pre><code class="language-bash"># minimal-notebook/Dockerfile, top section:
ARG BASE_CONTAINER=jupyter/base-notebook

# scipy-notebook/Dockerfile, top section:
ARG BASE_CONTAINER=jupyter/minimal-notebook

# datascience-notebook/Dockerfile, top section:
ARG BASE_CONTAINER=jupyter/scipy-notebook

# pyspark-notebook/Dockerfile, top section:
ARG BASE_CONTAINER=jupyter/scipy-notebook
</code></pre>

The docker-stacks team has structured the project so you can specify how complicated of a setup you want out of the box based on what image you select. The <code>jupyter/minimal-notebook</code> image will contain the simplest installation you need for jupyter to run at all. The <code>jupyter/pyspark-notebook</code> image will come with a lot more, like a spark installation in the jupyter container file system (likely overkill unless you're using pyspark!). Higher up images in the inheritance tree will include everything below them (e.g. pyspark-notebook contains everything from scipy-notebook, minimal-notebook, and base-notebook).

<br>
<h3 class="h3-text"><i>Custom File 1: Docker Compose</i></h2>

The first file we add to the <code>docker-stacks</code> base repo is <code>docker-compose.yml</code>. The <code>docker-compose</code> tool is often used for orchestrating many containers (e.g. "bring up an nginx container and a jupyter container together so nginx can act as a reverse proxy and make the jupyter URL more user-friendly"), but here we only have one container (<code>jupyter</code>). I like to use <code>docker-compose.yml</code> as a way of version controlling a <code>docker run</code> command, which is typically used to bring single containers up. All <code>docker-run</code> commands can be translated into <code>docker-compose</code> files and vice versa.

<br><br>
You'll create a <code>docker-stacks/docker-compose.yml</code> file that looks something like this (totally up to you to customize!):
<pre><code class="language-bash">############################################
## docker-stacks/docker-compose.yml ##
############################################
version: '3'

services:

  jupyter:
    container_name: jupyter
    image: jupyter/minimal-notebook # always get `latest` image on docker hub
    # image: jupyter/pyspark-notebook:1386e2046833 # tagged/pinned image example. check for updates here: https://hub.docker.com/r/jupyter/pyspark-notebook/tags.
    volumes:
      - ~/:/home/jovyan/work/
      - ./setup_envs.sh:/usr/local/bin/before-notebook.d/setup_envs.sh
    ports:
      - 9999:9999
    restart: unless-stopped
    environment:
      JUPYTER_ENABLE_LAB: 'yes'
    command: >
      sh -c "bash start-notebook.sh\
                 --NotebookApp.token=$JUPYTER_PASSWORD\
                 --NotebookApp.notebook_dir=/home/jovyan/work/\
                 --port 9999"
</code></pre>

Meaning of this witchcraft:
<ul>
    <li><code>version '3'</code>: docker-compose specifies versions. They have slightly different syntax between them</li>
    <li><code>services</code>: our list of services here is just one service called jupyter that will create a container called jupyter</li>
    <li><code>image</code>: here is where you call out which image you want to use, as discussed above</li>
    <li><code>volumes</code>: this is how you break isolation between the container and host environment, linking directories and/or files from the host to the container filesystems. This is important because otherwise when you destroy your container, your files would be lost with it. Syntax is <code>host_path:container_path</code>. Changes made in either host or container will reflect in the other</li>
    <li><code>ports</code>: jupyter will run on a port in the container. <code>ports</code> binds the host port to the container port. Syntax is <code>host_port:container_port</code></li>
    <li><code>restart: unless-stopped</code>: if your container fails, it will auto-restart unless you stop it with e.g. <code>docker-compose down</code></li>
    <li><code>environment</code>: specify environment variables. <code>JUPYTER_ENABLE_LAB</code> enables jupyter lab by default</li>
    <li><code>command</code>: this is the final command docker will run in the container upon build. <code>NotebookApp.token</code> password-protects your jupyter instance. The port here should also match the container port in <code>ports</code> above</li>
</ul>

<h3 class="h3-text"><i>Custom File 2: Setup Script</i></h2>

You may have noticed that the second volume specified in the <code>docker-compose.yml</code> file is called <code>./setup_envs.sh</code>. This is a custom startup script that I use to do the following:
<ul>
    <li>Create environment variables that are accessible in jupyter</li>
    <li>Add jupyterlab extensions</li>
    <li>Create custom conda environments and link them to jupyter kernels</li>
    <li>Run other useful commands in the container upon startup (e.g. configure git, install <code>vim</code> or <code>svn</code>, etc.)</li>
</ul>

You'll create a <code>docker-stacks/setup_envs.sh</code> file that looks something like this (totally up to you to customize!):
<pre><code class="language-bash">############################################
## example docker-stacks/setup_envs.sh ##
############################################
echo ""
echo "Creating useful environment variables..."
export MYVAR=$MYVAR
export MYVAR2=$MYVAR2
echo "Finished creating useful environment variables!"

echo ""
echo "Adding jupyterlab extensions..."
rm -rf /home/jovyan/work/extensions
mkdir /home/jovyan/work/extensions

# Great extension by calpoly for better markdown formatting in cells: https://github.com/jupytercalpoly/jupyterlab-richtext-mode
git clone https://github.com/jupytercalpoly/jupyterlab-richtext-mode.git /home/jovyan/work/extensions/jupyter-scribe && \
cd /home/jovyan/work/extensions/jupyter-scribe && \
npm install && \
npm run build && \
jupyter labextension link .

# Rebuild to get extensions to work
jlpm build
jupyter lab build
echo "Added jupyterlab extensions!"

echo ""
echo "Creating kernel py37..."
conda create -n py37 python=3.7.4 pip -y
echo "Finished creating kernel py37!"

# Install packages with pip, otherwise conda's "auto-checking compatibility" algo freaks out (with certain versions of conda)
echo ""
echo "Installing packages in py37..."
source activate py37 && \
pip install ipykernel && \
pip install pandas && \
pip install numpy && \
pip install scipy && \
pip install matplotlib && \
pip install seaborn && \
echo "Finished installing packages in py37!"

echo ""
echo "Connecting env to kernel..."
source activate py37 && python -m ipykernel install --user --name py37 --display-name "py37"
source activate py37 # must activate/deactivate once to have changes displayed
source activate base
echo "Connected env to kernel!"

cat << "EOF"

WELCOME!

     ██╗██╗   ██╗██████╗ ██╗   ██╗████████╗███████╗██████╗
     ██║██║   ██║██╔══██╗╚██╗ ██╔╝╚══██╔══╝██╔════╝██╔══██╗
     ██║██║   ██║██████╔╝ ╚████╔╝    ██║   █████╗  ██████╔╝
██   ██║██║   ██║██╔═══╝   ╚██╔╝     ██║   ██╔══╝  ██╔══██╗
╚█████╔╝╚██████╔╝██║        ██║      ██║   ███████╗██║  ██║
 ╚════╝  ╚═════╝ ╚═╝        ╚═╝      ╚═╝   ╚══════╝╚═╝  ╚═╝

Take it from here...

EOF
</code></pre>

<u>Dirty details on how this runs just by placing it in the container:</u> the <code>start-notebook.sh</code> script run by the <code>docker-compose</code> command will subsequently run <code>start.sh</code>. Both these shell scripts are in the <code>base-notebook</code> directory. The <code>start.sh</code> script has "hooks" for running scripts that are in the <code>/usr/local/bin/before-notebook.d</code>. <b>All this to say that <code>setup_envs.sh</code> will be run as part of your jupyter setup</b> (at the end) because we put it in the <code>/usr/local/bin/before-notebook.d</code> directory in the jupyter container!

<br><br>
Note that you could totally exclude the <code>setup_envs.sh</code> script and volume and your deployment would work 100%. I like to use this method as a way of customizing my jupyter setup in a version-controlled manner. Rather than installing a new python package in my base environment or installing a system package every time manually and trying to remember what I did when I port to a new machine, I'll edit the <code>setup_envs.sh</code> script and redeploy the jupyter container with <code>docker-compose restart</code>!

<br>
<h2 class="h2-text">3: Bring Up the Jupyter Container</h2>

If you've gotten this far, you're basically done! The one thing we're missing is to set a password/token. In terminal, run this command with your custom password. If you don't do this, <code>docker-compose</code> will warn you at the next step.
<pre><code class="language-bash">export JUPYTER_PASSWORD=$MY_CUSTOM_PASSWORD
</code></pre>

<br>
You can now navigate to the <code>docker-stacks</code> directory in a terminal and run
<pre><code class="language-bash">docker-compose up -d
</code></pre>
The <code>-d</code> flag stands for "detached", and ensures that container will stay running even if you exit the terminal you ran it in.

<br><br>
You can now run
<pre><code class="language-bash">docker logs -f jupyter
</code></pre>
The <code>-f</code> flag standing for "follow". Watch the progress in your terminal as your jupyter container is instantiated and your <code>setup_envs.sh</code> script is run (if you have one and copied it to the right directory as a volume).

<br><br>
Once you see something like the following:
<pre><code class="language-bash">[I 16:19:04.574 LabApp] The Jupyter Notebook is running at:
[I 16:19:04.574 LabApp] http://3204808557f5:9999/?token=...
[I 16:19:04.575 LabApp]  or http://127.0.0.1:9999/?token=...
[I 16:19:04.575 LabApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation).
</code></pre>
You're ready to go! Navigate to <a href="http://127.0.0.1:9999">http://127.0.0.1:9999</a> (or whatever port you specified if different than 9999) where you should see a page that prompts you for your token!

<br><br>
<i>Further thoughts:
<ul>
    <li>Another approach to version controlled customization could be to modify the Dockerfiles themselves. I prefer the <code>setup_envs.sh</code> script approach as rebuilding the Dockerfiles is time and disc-space intensive, but this is a totally valid approach.</li>
    <li>If you get stuck on anything in this process or see that I've been wrong/unclear about something, please open an issue on the source of this website <a href="https://github.com/robinovitch61/robinovitch61.github.io">here</a></li>
</ul>
</i>
<br><br>
<br><br>
</div>
        <script src="/assets/js/prism.js"></script>
    </body>
    
</html>
